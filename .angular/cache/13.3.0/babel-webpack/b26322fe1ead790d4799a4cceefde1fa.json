{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar core_1 = require(\"@angular/core\");\n\nvar common_1 = require(\"@angular/common\");\n\nvar sidebar_container_component_1 = require(\"./sidebar-container.component\");\n\nvar utils_1 = require(\"./utils\");\n\nvar Sidebar =\n/** @class */\nfunction () {\n  function Sidebar(_container, _ref, platformId) {\n    this._container = _container;\n    this._ref = _ref; // `openedChange` allows for \"2-way\" data binding\n\n    this.opened = false;\n    this.openedChange = new core_1.EventEmitter();\n    this.mode = 'over';\n    this.dock = false;\n    this.dockedSize = '0px';\n    this.position = 'start';\n    this.animate = true;\n    this.autoCollapseOnInit = true;\n    this.trapFocus = false;\n    this.autoFocus = true;\n    this.showBackdrop = false;\n    this.closeOnClickBackdrop = false;\n    this.closeOnClickOutside = false;\n    this.keyClose = false;\n    this.keyCode = 27; // Default to ESC key\n\n    this.onOpenStart = new core_1.EventEmitter();\n    this.onOpened = new core_1.EventEmitter();\n    this.onCloseStart = new core_1.EventEmitter();\n    this.onClosed = new core_1.EventEmitter();\n    this.onTransitionEnd = new core_1.EventEmitter();\n    this.onModeChange = new core_1.EventEmitter();\n    this.onPositionChange = new core_1.EventEmitter();\n    /** @internal */\n\n    this._onRerender = new core_1.EventEmitter();\n    this._focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]),' + 'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';\n    this._tabIndexAttr = '__tabindex__';\n    this._tabIndexIndicatorAttr = '__ngsidebar-tabindex__';\n    this._clickEvent = 'click';\n    this._onClickOutsideAttached = false;\n    this._onKeyDownAttached = false;\n    this._onResizeAttached = false;\n\n    if (!this._container) {\n      throw new Error('<ng-sidebar> must be inside a <ng-sidebar-container>. ' + 'See https://github.com/arkon/ng-sidebar#usage for more info.');\n    }\n\n    this._isBrowser = common_1.isPlatformBrowser(platformId); // Handle taps in iOS\n\n    if (this._isBrowser && utils_1.isIOS() && !('onclick' in window)) {\n      this._clickEvent = 'touchstart';\n    }\n\n    this._normalizePosition();\n\n    this.open = this.open.bind(this);\n    this.close = this.close.bind(this);\n    this._onTransitionEnd = this._onTransitionEnd.bind(this);\n    this._onFocusTrap = this._onFocusTrap.bind(this);\n    this._onClickOutside = this._onClickOutside.bind(this);\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._collapse = this._collapse.bind(this);\n  }\n\n  Sidebar.prototype.ngOnInit = function () {\n    if (!this._isBrowser) {\n      return;\n    }\n\n    if (this.animate) {\n      this._shouldAnimate = true;\n      this.animate = false;\n    }\n\n    this._container._addSidebar(this);\n\n    if (this.autoCollapseOnInit) {\n      this._collapse();\n    }\n  };\n\n  Sidebar.prototype.ngOnChanges = function (changes) {\n    var _this = this;\n\n    if (!this._isBrowser) {\n      return;\n    }\n\n    if (changes['animate'] && this._shouldAnimate) {\n      this._shouldAnimate = changes['animate'].currentValue;\n    }\n\n    if (changes['closeOnClickOutside']) {\n      if (changes['closeOnClickOutside'].currentValue) {\n        this._initCloseClickListener();\n      } else {\n        this._destroyCloseClickListener();\n      }\n    }\n\n    if (changes['keyClose']) {\n      if (changes['keyClose'].currentValue) {\n        this._initCloseKeyDownListener();\n      } else {\n        this._destroyCloseKeyDownListener();\n      }\n    }\n\n    if (changes['position']) {\n      // Handle \"start\" and \"end\" aliases\n      this._normalizePosition(); // Emit change in timeout to allow for position change to be rendered first\n\n\n      setTimeout(function () {\n        _this.onPositionChange.emit(changes['position'].currentValue);\n      });\n    }\n\n    if (changes['mode']) {\n      setTimeout(function () {\n        _this.onModeChange.emit(changes['mode'].currentValue);\n      });\n    }\n\n    if (changes['dock']) {\n      this.triggerRerender();\n    }\n\n    if (changes['autoCollapseHeight'] || changes['autoCollapseWidth']) {\n      this._initCollapseListeners();\n    }\n\n    if (changes['opened']) {\n      if (this._shouldAnimate) {\n        this.animate = true;\n        this._shouldAnimate = false;\n      }\n\n      if (changes['opened'].currentValue) {\n        this.open();\n      } else {\n        this.close();\n      }\n    }\n  };\n\n  Sidebar.prototype.ngOnDestroy = function () {\n    if (!this._isBrowser) {\n      return;\n    }\n\n    this._destroyCloseListeners();\n\n    this._destroyCollapseListeners();\n\n    this._container._removeSidebar(this);\n  }; // Sidebar toggling\n  // ==============================================================================================\n\n  /**\n   * Opens the sidebar and emits the appropriate events.\n   */\n\n\n  Sidebar.prototype.open = function () {\n    var _this = this;\n\n    if (!this._isBrowser) {\n      return;\n    }\n\n    this.opened = true;\n    this.openedChange.emit(true);\n    this.onOpenStart.emit();\n\n    this._ref.detectChanges();\n\n    setTimeout(function () {\n      if (_this.animate && !_this._isModeSlide) {\n        _this._elSidebar.nativeElement.addEventListener('transitionend', _this._onTransitionEnd);\n      } else {\n        _this._setFocused();\n\n        _this._initCloseListeners();\n\n        if (_this.opened) {\n          _this.onOpened.emit();\n        }\n      }\n    });\n  };\n  /**\n   * Closes the sidebar and emits the appropriate events.\n   */\n\n\n  Sidebar.prototype.close = function () {\n    var _this = this;\n\n    if (!this._isBrowser) {\n      return;\n    }\n\n    this.opened = false;\n    this.openedChange.emit(false);\n    this.onCloseStart.emit();\n\n    this._ref.detectChanges();\n\n    setTimeout(function () {\n      if (_this.animate && !_this._isModeSlide) {\n        _this._elSidebar.nativeElement.addEventListener('transitionend', _this._onTransitionEnd);\n      } else {\n        _this._setFocused();\n\n        _this._destroyCloseListeners();\n\n        if (!_this.opened) {\n          _this.onClosed.emit();\n        }\n      }\n    });\n  };\n  /**\n   * Manually trigger a re-render of the container. Useful if the sidebar contents might change.\n   */\n\n\n  Sidebar.prototype.triggerRerender = function () {\n    var _this = this;\n\n    if (!this._isBrowser) {\n      return;\n    }\n\n    setTimeout(function () {\n      _this._onRerender.emit();\n    });\n  };\n  /**\n   * @internal\n   *\n   * Computes the transform styles for the sidebar template.\n   *\n   * @return {CSSStyleDeclaration} The transform styles, with the WebKit-prefixed version as well.\n   */\n\n\n  Sidebar.prototype._getStyle = function () {\n    var transformStyle = ''; // Hides sidebar off screen when closed\n\n    if (!this.opened) {\n      var transformDir = 'translate' + (this._isLeftOrRight ? 'X' : 'Y');\n      var translateAmt = (this._isLeftOrTop ? '-' : '') + \"100%\";\n      transformStyle = transformDir + \"(\" + translateAmt + \")\"; // Docked mode: partially remains open\n      // Note that using `calc(...)` within `transform(...)` doesn't work in IE\n\n      if (this.dock && this._dockedSize > 0 && !(this._isModeSlide && this.opened)) {\n        transformStyle += \" \" + transformDir + \"(\" + (this._isLeftOrTop ? '+' : '-') + this.dockedSize + \")\";\n      }\n    }\n\n    return {\n      webkitTransform: transformStyle,\n      transform: transformStyle\n    };\n  };\n  /**\n   * @internal\n   *\n   * Handles the `transitionend` event on the sidebar to emit the onOpened/onClosed events after the transform\n   * transition is completed.\n   */\n\n\n  Sidebar.prototype._onTransitionEnd = function (e) {\n    if (e.target === this._elSidebar.nativeElement && e.propertyName.endsWith('transform')) {\n      this._setFocused();\n\n      if (this.opened) {\n        this._initCloseListeners();\n\n        this.onOpened.emit();\n      } else {\n        this._destroyCloseListeners();\n\n        this.onClosed.emit();\n      }\n\n      this.onTransitionEnd.emit();\n\n      this._elSidebar.nativeElement.removeEventListener('transitionend', this._onTransitionEnd);\n    }\n  };\n\n  Object.defineProperty(Sidebar.prototype, \"_shouldTrapFocus\", {\n    // Focus on open/close\n    // ==============================================================================================\n\n    /**\n     * Returns whether focus should be trapped within the sidebar.\n     *\n     * @return {boolean} Trap focus inside sidebar.\n     */\n    get: function () {\n      return this.opened && this.trapFocus;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Sets focus to the first focusable element inside the sidebar.\n   */\n\n  Sidebar.prototype._focusFirstItem = function () {\n    if (this._focusableElements && this._focusableElements.length > 0) {\n      this._focusableElements[0].focus();\n    }\n  };\n  /**\n   * Loops focus back to the start of the sidebar if set to do so.\n   */\n\n\n  Sidebar.prototype._onFocusTrap = function (e) {\n    if (this._shouldTrapFocus && !this._elSidebar.nativeElement.contains(e.target)) {\n      this._focusFirstItem();\n    }\n  };\n  /**\n   * Handles the ability to focus sidebar elements when it's open/closed to ensure that the sidebar is inert when\n   * appropriate.\n   */\n\n\n  Sidebar.prototype._setFocused = function () {\n    this._focusableElements = Array.from(this._elSidebar.nativeElement.querySelectorAll(this._focusableElementsString));\n\n    if (this.opened) {\n      this._focusedBeforeOpen = document.activeElement; // Restore focusability, with previous tabindex attributes\n\n      for (var _i = 0, _a = this._focusableElements; _i < _a.length; _i++) {\n        var el = _a[_i];\n        var prevTabIndex = el.getAttribute(this._tabIndexAttr);\n        var wasTabIndexSet = el.getAttribute(this._tabIndexIndicatorAttr) !== null;\n\n        if (prevTabIndex !== null) {\n          el.setAttribute('tabindex', prevTabIndex);\n          el.removeAttribute(this._tabIndexAttr);\n        } else if (wasTabIndexSet) {\n          el.removeAttribute('tabindex');\n          el.removeAttribute(this._tabIndexIndicatorAttr);\n        }\n      }\n\n      if (this.autoFocus) {\n        this._focusFirstItem();\n      }\n\n      document.addEventListener('focus', this._onFocusTrap, true);\n    } else {\n      // Manually make all focusable elements unfocusable, saving existing tabindex attributes\n      for (var _b = 0, _c = this._focusableElements; _b < _c.length; _b++) {\n        var el = _c[_b];\n        var existingTabIndex = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n        el.setAttribute(this._tabIndexIndicatorAttr, '');\n\n        if (existingTabIndex !== null) {\n          el.setAttribute(this._tabIndexAttr, existingTabIndex);\n        }\n      }\n\n      document.removeEventListener('focus', this._onFocusTrap, true); // Set focus back to element before the sidebar was opened\n\n      if (this._focusedBeforeOpen && this.autoFocus && this._isModeOver) {\n        this._focusedBeforeOpen.focus();\n\n        this._focusedBeforeOpen = null;\n      }\n    }\n  }; // Close event handlers\n  // ==============================================================================================\n\n  /**\n   * Initializes event handlers for the closeOnClickOutside and keyClose options.\n   */\n\n\n  Sidebar.prototype._initCloseListeners = function () {\n    this._initCloseClickListener();\n\n    this._initCloseKeyDownListener();\n  };\n\n  Sidebar.prototype._initCloseClickListener = function () {\n    var _this = this; // In a timeout so that things render first\n\n\n    setTimeout(function () {\n      if (_this.opened && _this.closeOnClickOutside && !_this._onClickOutsideAttached) {\n        document.addEventListener(_this._clickEvent, _this._onClickOutside);\n        _this._onClickOutsideAttached = true;\n      }\n    });\n  };\n\n  Sidebar.prototype._initCloseKeyDownListener = function () {\n    var _this = this; // In a timeout so that things render first\n\n\n    setTimeout(function () {\n      if (_this.opened && _this.keyClose && !_this._onKeyDownAttached) {\n        document.addEventListener('keydown', _this._onKeyDown);\n        _this._onKeyDownAttached = true;\n      }\n    });\n  };\n  /**\n   * Destroys all event handlers from _initCloseListeners.\n   */\n\n\n  Sidebar.prototype._destroyCloseListeners = function () {\n    this._destroyCloseClickListener();\n\n    this._destroyCloseKeyDownListener();\n  };\n\n  Sidebar.prototype._destroyCloseClickListener = function () {\n    if (this._onClickOutsideAttached) {\n      document.removeEventListener(this._clickEvent, this._onClickOutside);\n      this._onClickOutsideAttached = false;\n    }\n  };\n\n  Sidebar.prototype._destroyCloseKeyDownListener = function () {\n    if (this._onKeyDownAttached) {\n      document.removeEventListener('keydown', this._onKeyDown);\n      this._onKeyDownAttached = false;\n    }\n  };\n  /**\n   * Handles `click` events on anything while the sidebar is open for the closeOnClickOutside option.\n   * Programatically closes the sidebar if a click occurs outside the sidebar.\n   *\n   * @param e {MouseEvent} Mouse click event.\n   */\n\n\n  Sidebar.prototype._onClickOutside = function (e) {\n    if (this._onClickOutsideAttached && this._elSidebar && !this._elSidebar.nativeElement.contains(e.target)) {\n      this.close();\n    }\n  };\n  /**\n   * Handles the `keydown` event for the keyClose option.\n   *\n   * @param e {KeyboardEvent} Normalized keydown event.\n   */\n\n\n  Sidebar.prototype._onKeyDown = function (e) {\n    e = e || window.event;\n\n    if (e.keyCode === this.keyCode) {\n      this.close();\n    }\n  }; // Auto collapse handlers\n  // ==============================================================================================\n\n\n  Sidebar.prototype._initCollapseListeners = function () {\n    var _this = this;\n\n    if (this.autoCollapseHeight || this.autoCollapseWidth) {\n      // In a timeout so that things render first\n      setTimeout(function () {\n        if (!_this._onResizeAttached) {\n          window.addEventListener('resize', _this._collapse);\n          _this._onResizeAttached = true;\n        }\n      });\n    }\n  };\n\n  Sidebar.prototype._destroyCollapseListeners = function () {\n    if (this._onResizeAttached) {\n      window.removeEventListener('resize', this._collapse);\n      this._onResizeAttached = false;\n    }\n  };\n\n  Sidebar.prototype._collapse = function () {\n    var winHeight = window.innerHeight;\n    var winWidth = window.innerWidth;\n\n    if (this.autoCollapseHeight) {\n      if (winHeight <= this.autoCollapseHeight && this.opened) {\n        this._wasCollapsed = true;\n        this.close();\n      } else if (winHeight > this.autoCollapseHeight && this._wasCollapsed) {\n        this.open();\n        this._wasCollapsed = false;\n      }\n    }\n\n    if (this.autoCollapseWidth) {\n      if (winWidth <= this.autoCollapseWidth && this.opened) {\n        this._wasCollapsed = true;\n        this.close();\n      } else if (winWidth > this.autoCollapseWidth && this._wasCollapsed) {\n        this.open();\n        this._wasCollapsed = false;\n      }\n    }\n  };\n\n  Object.defineProperty(Sidebar.prototype, \"_height\", {\n    // Helpers\n    // ==============================================================================================\n\n    /**\n     * @internal\n     *\n     * Returns the rendered height of the sidebar (or the docked size).\n     * This is used in the sidebar container.\n     *\n     * @return {number} Height of sidebar.\n     */\n    get: function () {\n      if (this._elSidebar.nativeElement) {\n        return this._isDocked ? this._dockedSize : this._elSidebar.nativeElement.offsetHeight;\n      }\n\n      return 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_width\", {\n    /**\n     * @internal\n     *\n     * Returns the rendered width of the sidebar (or the docked size).\n     * This is used in the sidebar container.\n     *\n     * @return {number} Width of sidebar.\n     */\n    get: function () {\n      if (this._elSidebar.nativeElement) {\n        return this._isDocked ? this._dockedSize : this._elSidebar.nativeElement.offsetWidth;\n      }\n\n      return 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_dockedSize\", {\n    /**\n     * @internal\n     *\n     * Returns the docked size as a number.\n     *\n     * @return {number} Docked size.\n     */\n    get: function () {\n      return parseFloat(this.dockedSize);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isModeOver\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is over mode.\n     *\n     * @return {boolean} Sidebar's mode is \"over\".\n     */\n    get: function () {\n      return this.mode === 'over';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isModePush\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is push mode.\n     *\n     * @return {boolean} Sidebar's mode is \"push\".\n     */\n    get: function () {\n      return this.mode === 'push';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isModeSlide\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is slide mode.\n     *\n     * @return {boolean} Sidebar's mode is \"slide\".\n     */\n    get: function () {\n      return this.mode === 'slide';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isDocked\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is \"docked\" -- i.e. it is closed but in dock mode.\n     *\n     * @return {boolean} Sidebar is docked.\n     */\n    get: function () {\n      return this.dock && this.dockedSize && !this.opened;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isLeftOrTop\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is positioned at the left or top.\n     *\n     * @return {boolean} Sidebar is positioned at the left or top.\n     */\n    get: function () {\n      return this.position === 'left' || this.position === 'top';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isLeftOrRight\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is positioned at the left or right.\n     *\n     * @return {boolean} Sidebar is positioned at the left or right.\n     */\n    get: function () {\n      return this.position === 'left' || this.position === 'right';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sidebar.prototype, \"_isInert\", {\n    /**\n     * @internal\n     *\n     * Returns whether the sidebar is inert -- i.e. the contents cannot be focused.\n     *\n     * @return {boolean} Sidebar is inert.\n     */\n    get: function () {\n      return !this.opened && !this.dock;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * \"Normalizes\" position. For example, \"start\" would be \"left\" if the page is LTR.\n   */\n\n  Sidebar.prototype._normalizePosition = function () {\n    var ltr = utils_1.isLTR();\n\n    if (this.position === 'start') {\n      this.position = ltr ? 'left' : 'right';\n    } else if (this.position === 'end') {\n      this.position = ltr ? 'right' : 'left';\n    }\n  };\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"opened\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"openedChange\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", String)], Sidebar.prototype, \"mode\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"dock\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", String)], Sidebar.prototype, \"dockedSize\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", String)], Sidebar.prototype, \"position\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"animate\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Number)], Sidebar.prototype, \"autoCollapseHeight\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Number)], Sidebar.prototype, \"autoCollapseWidth\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"autoCollapseOnInit\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", String)], Sidebar.prototype, \"sidebarClass\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", String)], Sidebar.prototype, \"ariaLabel\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"trapFocus\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"autoFocus\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"showBackdrop\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"closeOnClickBackdrop\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"closeOnClickOutside\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Boolean)], Sidebar.prototype, \"keyClose\", void 0);\n\n  __decorate([core_1.Input(), __metadata(\"design:type\", Number)], Sidebar.prototype, \"keyCode\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onOpenStart\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onOpened\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onCloseStart\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onClosed\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onTransitionEnd\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onModeChange\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"onPositionChange\", void 0);\n\n  __decorate([core_1.Output(), __metadata(\"design:type\", core_1.EventEmitter)], Sidebar.prototype, \"_onRerender\", void 0);\n\n  __decorate([core_1.ViewChild('sidebar', {\n    static: false\n  }), __metadata(\"design:type\", core_1.ElementRef)], Sidebar.prototype, \"_elSidebar\", void 0);\n\n  Sidebar = __decorate([core_1.Component({\n    selector: 'ng-sidebar',\n    template: \"\\n    <aside #sidebar\\n      role=\\\"complementary\\\"\\n      [attr.aria-hidden]=\\\"!opened\\\"\\n      [attr.aria-label]=\\\"ariaLabel\\\"\\n      class=\\\"ng-sidebar ng-sidebar--{{opened ? 'opened' : 'closed'}} ng-sidebar--{{position}} ng-sidebar--{{mode}}\\\"\\n      [class.ng-sidebar--docked]=\\\"_isDocked\\\"\\n      [class.ng-sidebar--inert]=\\\"_isInert\\\"\\n      [class.ng-sidebar--animate]=\\\"animate\\\"\\n      [ngClass]=\\\"sidebarClass\\\"\\n      [ngStyle]=\\\"_getStyle()\\\">\\n      <ng-content></ng-content>\\n    </aside>\\n  \",\n    styles: [\"\\n    .ng-sidebar {\\n      -webkit-overflow-scrolling: touch;\\n      overflow: auto;\\n      pointer-events: auto;\\n      position: absolute;\\n      touch-action: auto;\\n      will-change: initial;\\n      z-index: 2;\\n    }\\n\\n    .ng-sidebar--left {\\n      bottom: 0;\\n      left: 0;\\n      top: 0;\\n    }\\n\\n    .ng-sidebar--right {\\n      bottom: 0;\\n      right: 0;\\n      top: 0;\\n    }\\n\\n    .ng-sidebar--top {\\n      left: 0;\\n      right: 0;\\n      top: 0;\\n    }\\n\\n    .ng-sidebar--bottom {\\n      bottom: 0;\\n      left: 0;\\n      right: 0;\\n    }\\n\\n    .ng-sidebar--inert {\\n      pointer-events: none;\\n      touch-action: none;\\n      will-change: transform;\\n    }\\n\\n    .ng-sidebar--animate {\\n      -webkit-transition: -webkit-transform 0.3s cubic-bezier(0, 0, 0.3, 1);\\n      transition: transform 0.3s cubic-bezier(0, 0, 0.3, 1);\\n    }\\n  \"],\n    changeDetection: core_1.ChangeDetectionStrategy.OnPush\n  }), __param(0, core_1.Optional()), __param(2, core_1.Inject(core_1.PLATFORM_ID)), __metadata(\"design:paramtypes\", [sidebar_container_component_1.SidebarContainer, core_1.ChangeDetectorRef, Object])], Sidebar);\n  return Sidebar;\n}();\n\nexports.Sidebar = Sidebar;","map":null,"metadata":{},"sourceType":"script"}